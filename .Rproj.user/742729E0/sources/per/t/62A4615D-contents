
checkControl.NullModel.SPACox = function(control)
{
  default.control = list(range = c(-100, 100),
                         length.out = 10000)
  
  # use the default setting or update it
  if(!is.null(control)){
    ctrl.nm = names(control)
    for(nm in ctrl.nm){
      default.control[[nm]] = control[[nm]]
    }
  }
  
  control = default.control
  
  # check the parameters
  range = control$range
  length.out = control$length.out
  
  if(range[1] >= -50 | range[2] <= 50 | length.out <= 1000)
    stop("We suggest setting argument 'control$range=c(-100,100)' and 'control$length.out=10000'.")
  
  if(range[2]!=-1*range[1])
    stop("range[2] should be -1*range[1]")
  
  return(control)
}

fitNullModel.SPACox = function(formula, data, subjData, subjGeno, control, ...)
{
  ### extract information from control
  range = control$range
  length.out = control$length.out
  print(range)
  print(length.out)
  
  ### Fit a Cox model using survival package
  obj.coxph = survival::coxph(formula, data=data, x=T, na.action="na.omit", ...)
  
  if(!is.null(obj.coxph$na.action)){
    posNA = c(obj.coxph$na.action)
    if(any(posNA > length(subjData)))
      stop("Please check the consistency between 'formula' and 'subjData'.")
    
    print(paste0("Due to missing data in response/indicators, ",length(posNA)," entries are removed from analysis."))
    print("If concerned about the power loss, users can impute data first and then use SPACox package.")
    
    subjData = subjData[-1*posNA]  # remove IDs with missing data
  }
  
  mresid = obj.coxph$residuals
  
  if(length(mresid)!=length(subjData))
    stop("Please check the consistency between 'formula' and 'subjData'.")
  
  ### Get the covariate matrix to adjust for genotype
  Cova = obj.coxph$x
  
  X = cbind(1, Cova)
  X.invXX = X %*% solve(t(X)%*%X)
  tX = t(X)
  
  ### calculate empirical CGF for martingale residuals
  idx0 = qcauchy(1:length.out/(length.out+1))
  idx1 = idx0 * max(range) / max(idx0)
  
  cumul = NULL
  print("Start calculating empirical CGF for martingale residuals...")
  c = 0
  for(i in idx1){
    c = c+1
    t = i
    e_resid = exp(mresid*t)
    M0 = mean(e_resid)
    M1 = mean(mresid*e_resid)
    M2 = mean(mresid^2*e_resid)
    K0 = log(M0)
    K1 = M1/M0
    K2 = (M0*M2-M1^2)/M0^2
    cumul = rbind(cumul, c(t, K0, K1, K2))
    if(c %% 1000 == 0) print(paste0("Complete ",c,"/",length.out,"."))
  }
  
  re = list(mresid = mresid,
            cumul = cumul,
            tX = tX,
            X.invXX = X.invXX,
            subjData = subjData, 
            subjGeno = subjGeno)
  
  class(re) = "SPACox_NULL_Model"
  return(re)
}


setMarker.SPACox = function(objNull, control)
{
  # do nothing since SPACox does not need this step
}


mainMarker.SPACox = function(objNull, control)
{
  OutList = mainMarkerInCPP("SPACox",
                            genoType,
                            markers,
                            control$SPA_cutoff,
                            control$missing_cutoff,
                            control$min_maf_region,
                            control$min_mac_region)  
  
  markerVec = OutList$markerVec   # marker IDs
  infoVec = OutList$infoVec       # marker infomation: CHR:POS:REF:ALT
  flipVec = OutList$flipVec       # 
  freqVec = OutList$freqVec       # minor allele frequencies (freq of ALT if flip=F, freq of REF if flip=T)
  # BetaVec = OutList$BetaVec       # beta for ALT if flip=F, beta for REF if flip=T
  # seBetaVec = OutList$seBetaVec   # sebeta
  PvalVec = OutList$pvalVec;      # marker-level p-values
  
  obj.mainMarker = data.frame(Marker = markerVec,
                              Info = infoVec,
                              Flip = flipVec,
                              Freq = freqVec,
                              # Beta = BetaVec,
                              # seBeta = seBetaVec,
                              Pval = PvalVec)
  
}


check_input1 = function(obj.null, Geno.mtx, par.list)
{
  if(class(obj.null)!="SPACox_NULL_Model")
    stop("obj.null should be a returned outcome from SPACox_Null_Model()")

  if(any(obj.null$gIDs != rownames(Geno.mtx))) stop("gIDs should be the same as rownames(Geno.mtx).")
  if(is.null(rownames(Geno.mtx))) stop("Row names of 'Geno.mtx' should be given.")
  if(is.null(colnames(Geno.mtx))) stop("Column names of 'Geno.mtx' should be given.")
  if(!is.numeric(Geno.mtx)|!is.matrix(Geno.mtx)) stop("Input 'Geno.mtx' should be a numeric matrix.")

  if(!is.numeric(par.list$min.maf)|par.list$min.maf<0|par.list$min.maf>0.5) stop("Argument 'min.maf' should be a numeric value >= 0 and <= 0.5.")
  if(!is.numeric(par.list$Cutoff)|par.list$Cutoff<0) stop("Argument 'Cutoff' should be a numeric value >= 0.")
  # if(!is.element(par.list$impute.method,c("none","bestguess","random","fixed"))) stop("Argument 'impute.method' should be 'none', 'bestguess', 'random' or 'fixed'.")
  if(!is.element(par.list$impute.method,c("fixed"))) stop("Argument 'impute.method' should be 'fixed'.")
  if(!is.numeric(par.list$missing.cutoff)|par.list$missing.cutoff<0|par.list$missing.cutoff>1) stop("Argument 'missing.cutoff' should be a numeric value between 0 and 1.")
  if(!is.element(par.list$G.model,c("Add","Dom","Rec"))) stop("Argument 'G.model' should be 'Add', 'Dom' or 'Rec'.")
}

