// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>

// using namespace Rcpp;

/*** R
inte = function(x, y, a, b){
  model = approxfun(x, y)
  return(integrate(model, a, b)$value)
}

.x <- 1:10
set.seed(123)
.y <- rnorm(10)
*/

// [[Rcpp::export]]
double intecxx(Rcpp::NumericVector x, Rcpp::NumericVector y, double a, double b) {  
  Rcpp::NumericVector res;
  Rcpp::Environment G = Rcpp::Environment::global_env();
  Rcpp::Function inte = G["inte"];
  res = inte(x, y, a, b);
  return res[0];
}

// [[Rcpp::export]]
Rcpp::Function approxfunInCPP(Rcpp::NumericVector x, Rcpp::NumericVector y, double a)
{
  Rcpp::Environment pkg = Rcpp::Environment::namespace_env("stats");
  Rcpp::Function approxfun = pkg["approxfun"];
  Rcpp::Function f = approxfun(x, y, Rcpp::Named("rule")=2);
  // double b = f(a);
  return f;
}

// [[Rcpp::export]]
arma::vec func(arma::vec a, Rcpp::Function f)
{
  // SEXP b = f(a);
  arma::vec b1 = Rcpp::as<arma::vec>(f(a));
  return b1;
}

// [[Rcpp::export]]
double findRoot(Rcpp::Function f)
{
  Rcpp::Environment pkg = Rcpp::Environment::namespace_env("stats");
  Rcpp::Function uniroot = pkg["uniroot"];
  arma::vec intervalVec = {0, 1};
  Rcpp::List rootList = Rcpp::as<Rcpp::List>(uniroot(f, Rcpp::Named("interval")=intervalVec));
  double root = rootList["root"];
  return root;
}

// You can include R code blocks in C++ files processed with sourceCpp
// (useful for testing and development). The R code will be automatically 
// run after the compilation.
//

/*** R
inte(.x, .y, 1, 10)
x = sort(runif(10))
y = sort(rnorm(10))
f = approxfunInCPP(x, y, a)
func(c(0.5,0.6), f)
findRoot(f)
*/
